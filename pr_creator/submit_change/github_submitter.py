from __future__ import annotations

import logging
import os
import shutil
import subprocess
import urllib.parse
import uuid
from pathlib import Path
from typing import Optional, Tuple

from github import Github

from .base import SubmitChange

logger = logging.getLogger(__name__)


def _run(cmd: list[str], cwd: Path) -> None:
    logger.info("[submit] cwd=%s cmd=%s", cwd, " ".join(cmd))
    subprocess.run(cmd, cwd=str(cwd), check=True)


def _git_status_dirty(cwd: Path) -> bool:
    result = subprocess.run(
        ["git", "status", "--porcelain"],
        cwd=str(cwd),
        check=True,
        capture_output=True,
        text=True,
    )
    dirty = bool(result.stdout.strip())
    logger.info("[submit] status dirty=%s", dirty)
    return dirty


def _current_branch(cwd: Path) -> str:
    result = subprocess.run(
        ["git", "rev-parse", "--abbrev-ref", "HEAD"],
        cwd=str(cwd),
        check=True,
        capture_output=True,
        text=True,
    )
    return result.stdout.strip()


def _origin_url(cwd: Path) -> str:
    result = subprocess.run(
        ["git", "remote", "get-url", "origin"],
        cwd=str(cwd),
        check=True,
        capture_output=True,
        text=True,
    )
    url = result.stdout.strip()
    logger.info("[submit] origin url=%s", url)
    return url


def _parse_repo_slug(origin_url: str) -> Optional[str]:
    if origin_url.startswith("git@github.com:"):
        return origin_url.removeprefix("git@github.com:").removesuffix(".git")
    if origin_url.startswith("https://github.com/"):
        return origin_url.removeprefix("https://github.com/").removesuffix(".git")
    return None


def _token_push_url(origin_url: str, token: str, branch: str) -> Tuple[str, str]:
    slug = _parse_repo_slug(origin_url)
    if not slug:
        raise RuntimeError(f"Unsupported origin URL for token push: {origin_url}")
    encoded = urllib.parse.quote(token, safe="")
    push_url = f"https://{encoded}:x-oauth-basic@github.com/{slug}.git"
    return push_url, slug


class GithubSubmitter(SubmitChange):
    def __init__(self) -> None:
        # If SUBMIT_PR_BASE is not set, defer to the repo default branch.
        self.base_branch = os.environ.get("SUBMIT_PR_BASE") or None
        self.commit_message = os.environ.get(
            "SUBMIT_COMMIT_MESSAGE", "Automated changes"
        )
        self.pr_title = os.environ.get("SUBMIT_PR_TITLE", self.commit_message)
        self.pr_body = os.environ.get(
            "SUBMIT_PR_BODY", "Automated changes generated by pr-creator."
        )
        self.branch_prefix = os.environ.get("SUBMIT_BRANCH_PREFIX", "auto/pr")
        self.github_token = os.environ.get("GITHUB_TOKEN")

    def _ensure_tools(self) -> None:
        if shutil.which("git") is None:
            raise RuntimeError("git is required to submit changes")
        # gh is optional; checked at PR creation time.

    def _prepare_branch(self, repo_path: Path, base_branch: str) -> str:
        current = _current_branch(repo_path)
        logger.info("[submit] current branch=%s", current)
        # If we're already on a non-base branch (and not an auto/ branch), reuse it.
        if (
            current != "HEAD"
            and current != base_branch
            and not current.startswith("auto/")
        ):
            return current

        branch = f"{self.branch_prefix}-{uuid.uuid4().hex[:8]}"
        _run(["git", "checkout", "-B", branch], repo_path)
        return branch

    def _commit_changes(self, repo_path: Path) -> None:
        _run(["git", "add", "-A"], repo_path)
        _run(["git", "commit", "-m", self.commit_message], repo_path)

    def _push_branch(self, repo_path: Path, branch: str) -> None:
        origin = _origin_url(repo_path)
        token = self.github_token
        if not token:
            logger.warning("GITHUB_TOKEN not set; skipping push/PR")
            return
        push_url, _ = _token_push_url(origin, token, branch)
        _run(["git", "push", "--set-upstream", push_url, branch], repo_path)

    def submit(self, repo_path: Path) -> None:
        repo_path = Path(repo_path)
        self._ensure_tools()

        if _git_status_dirty(repo_path):
            self._commit_changes(repo_path)
        else:
            logger.info("[submit] no changes to commit; skipping PR creation")
            return

        origin = _origin_url(repo_path)

        base_branch = self.base_branch
        repo = None
        if self.github_token:
            gh = Github(self.github_token)
            slug = _parse_repo_slug(origin)
            if slug:
                repo = gh.get_repo(slug)
                if base_branch is None:
                    base_branch = repo.default_branch
        if base_branch is None:
            base_branch = "main"

        branch = self._prepare_branch(repo_path, base_branch)

        self._push_branch(repo_path, branch)

        if not self.github_token or repo is None:
            logger.warning("GITHUB_TOKEN not set; skipping PR creation")
            return

        logger.info("[submit] creating PR head=%s base=%s", branch, base_branch)
        repo.create_pull(
            title=self.pr_title,
            body=self.pr_body,
            head=branch,
            base=base_branch,
        )
